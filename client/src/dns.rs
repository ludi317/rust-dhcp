//! DNS configuration utilities

use log::{info, warn};
use std::fs;
use std::net::Ipv4Addr;
use std::path::Path;

const RESOLV_CONF_PATH: &str = "/etc/resolv.conf";
const BACKUP_PATH: &str = "/etc/resolv.conf.dhcp-backup";
const RESOLV_HEADER: &str = "# Generated by DHCP client\n";

/// Apply DNS configuration by updating /etc/resolv.conf
pub async fn apply_dns_config(dns_servers: &[Ipv4Addr], domain_name: Option<&str>) -> Result<(), Box<dyn std::error::Error>> {
    if Path::new(RESOLV_CONF_PATH).exists() && !Path::new(BACKUP_PATH).exists() {
        if let Err(e) = fs::copy(RESOLV_CONF_PATH, BACKUP_PATH) {
            warn!("Failed to backup existing resolv.conf: {}", e);
        }
    }

    // Build new resolv.conf content
    let mut content = String::new();
    content.push_str(RESOLV_HEADER);

    // Add domain if provided
    if let Some(domain) = domain_name {
        content.push_str(&format!("domain {}\n", domain));
        content.push_str(&format!("search {}\n", domain));
    }

    // Add nameservers
    for dns_server in dns_servers {
        content.push_str(&format!("nameserver {}\n", dns_server));
    }

    // Write new resolv.conf
    match fs::write(RESOLV_CONF_PATH, content) {
        Ok(()) => {
            info!("üìù Updated /etc/resolv.conf with {} DNS servers", dns_servers.len());
            if let Some(domain) = domain_name {
                info!("üìù Set domain to: {}", domain);
            }
            Ok(())
        }
        Err(e) => {
            // Try to restore backup if write failed
            if Path::new(BACKUP_PATH).exists() {
                if let Err(restore_err) = fs::copy(BACKUP_PATH, RESOLV_CONF_PATH) {
                    warn!("Failed to restore resolv.conf backup: {}", restore_err);
                }
            }
            Err(format!("Failed to write /etc/resolv.conf: {}", e).into())
        }
    }
}

/// Restore original DNS configuration from backup
pub async fn restore_dns_config() -> Result<(), Box<dyn std::error::Error>> {
    if Path::new(BACKUP_PATH).exists() {
        fs::copy(BACKUP_PATH, RESOLV_CONF_PATH)?;
        fs::remove_file(BACKUP_PATH)?;
        info!("üìù Restored original /etc/resolv.conf from backup");
        Ok(())
    } else {
        // No backup exists, just remove DHCP-generated file
        if Path::new(RESOLV_CONF_PATH).exists() {
            let content = fs::read_to_string(RESOLV_CONF_PATH)?;
            if content.starts_with(RESOLV_HEADER) {
                fs::remove_file(RESOLV_CONF_PATH)?;
                info!("üìù Removed DHCP-generated /etc/resolv.conf");
            }
        }
        Ok(())
    }
}